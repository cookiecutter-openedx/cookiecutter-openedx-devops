Getting Started Guide
=====================

The automation scripts generated by the Cookiecutter leverage seven key technologies with which you should familiarize yourself.

1. `Terraform <https://www.terraform.io/>`_ Terraform is an open-source infrastructure-as-code software tool created by HashiCorp. Users define and provide data center infrastructure using a declarative configuration language known as HashiCorp Configuration Language (hcl). HCL is a simple that you can learn in a few minutes. On the other hand, the various Terraform libraries that we leverage, mostly provided by `AWS <https://registry.terraform.io/providers/hashicorp/aws/latest/docs>`_ and `Kubernetes <https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs>`_, are knowledge intensive and require time and lots of hands-on experience.
2. `Terragrunt <https://terragrunt.gruntwork.io/>`_ Terragrunt is a Terraform templating tool for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. Terragrunt is our strategy for managing multiple environments and (if you so choose) multiple stacks.
3. `Kubernetes Manifests <https://kubernetes.io/docs/tasks/tools/>`_ Manifests are predefined YAML file formats that describe each of the 43 different kinds of resources that are available in a modern Kubernetes cluster. Manifests, applied using the Kubernetes CLI kubectl, are the exclusive means of defining and managing resources in Kubernetes.
4. `kubectl <https://kubernetes.io/docs/tasks/tools/>`_ The Kubernetes command-line tool, kubectl, allows you to run commands against Kubernetes clusters. kubectl is the exlusive means of communicating with a Kubernetes cluster. Terraform leverage kubectl indirectly via the `Kubernetes Provider <https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs>`_ which relies extensively on kubectl for all resources.
5. `Helm <https://helm.sh/>`_ Helm is an open-source graduated Cloud Native Computing Foundation project originally created by DeisLabs as a third-party utility, now known as the package manager for Kubernetes, focused on automating the Kubernetes applications lifecycle in a simple and consistent way. The objective of Helm as package manager is to make an easy and automated management (install, update, or uninstall) of packages for Kubernetes applications, and deploy them with just a few commands. The cookiecutter optionally can install a lot of high quality administrative software for you onto your Kubernetes cluster, and most of these packages are installed using Helm charts.
6. `Github Actions <https://github.com/features/actions>`_ GitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.
7. `AWS Command Line Interface <https://aws.amazon.com/cli/>`_ The AWS Command Line Interface (AWS CLI) is a unified tool to manage your AWS services. Terraform manages AWS resources through its indirect use of the AWS CLI which itself is called directly from the Terraform `AWS Provider <https://registry.terraform.io/providers/hashicorp/aws/latest/docs>`_

The Cookiecutter cutter is a good place to get acquainted with these technologies, as all of the source code is templated and follows industry best practices. You'll likely find existing working code patterns in the Cookiecutter for most things that you would want to accomplish on an ad hoc basis.

I. Setup your local environment
-------------------------------

The following *should* work for macOS, Linux and Windows. Most of the code in this repository is Terraform or Terragrunt. However,
running the Terraform modules will in turn invoke several other software packages; namely, the AWS Command Line Interface awscli, the Kubernetes
Command Line Interface kubectl, and Helm. For best results, you should regularly update all of these packages.

.. code-block:: shell

    $ brew install awscli python@3.8 black helm jq k9s kubernetes-cli pre-commit pyyaml terraform terragrunt tflint yq

    # configure awscli
    # first, follow these instructions to create an IAM keypair: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html
    # then afterwards, follow these instruction to configure awscli: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html
    $ aws configure
    AWS Access Key ID [None]: AKIAIOSFODNN7EXAMPLE
    AWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
    Default region name [None]: us-west-2
    Default output format [None]: json

    # add all Helm charts
    $ helm repo add bitnami https://charts.bitnami.com/bitnami
    $ helm repo add metrics-server https://kubernetes-sigs.github.io/metrics-server/
    $ helm repo add karpenter https://charts.karpenter.sh/
    $ helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    $ helm repo add cowboysysop https://cowboysysop.github.io/charts/
    $ helm repo add jetstack https://charts.jetstack.io
    $ helm repo update


II. Add Your Secret Credentials To Your New Repository
------------------------------------------------------

The Github Actions workflows in your new repository will depend on several workflow secrets including two sets of AWS IAM keypairs, one for CI workflows and another for the AWS Simple Email Service.
Additionally, they require a Github Personal Access Token (PAT) for a Github user account with all requisite privileges in your new repository as well as any other repositories that are cloned during any of the build / installation pipelines.

.. image:: ./repository-secrets.png
  :width: 700
  :alt: Github Repository Secrets

III. Review The Configuration For Your Open edX Back End
--------------------------------------------------------

Review your global parameters. These will be pre-populated from your responses to the Cookiecutter command-line questionnaire.

.. code-block:: hcl

  locals {
    platform_name    = "yourschool"
    platform_region  = "virginia"
    root_domain      = "yourschool.edu"
    aws_region       = "us-east-1"
    account_id       = "123456789012"
  }


Review your production environment parameters.

.. code-block:: hcl

  locals {

  environment           = "courses"

                          # defaults to this value
  environment_domain    = "courses.yourschool.edu"

                          # defaults to this value
  environment_namespace = "courses-yourschool-virginia"


  # AWS infrastructure default sizing

                                    # 1 vCPU 2gb
  mysql_instance_class            = "db.t2.small"

                                    # 1 vCPU 1.55gb
  redis_node_type                 = "cache.t2.small"

                                    # 2 vCPU 8gb
  eks_hosting_group_instance_type  = "t3.large"

                                      # 2 vCPU 8gb
  eks_service_group_instance_type = "t3.large"

  }



IV. Build Your Open edX Backend
-------------------------------

The backend build procedure is automated using `Terragrunt <https://terragrunt.gruntwork.io/>`_ for `Terraform <https://www.terraform.io/>`_.
Installation instructions are avilable at both of these web sites.

Terraform scripts rely on the `AWS CLI (Command Line Interface) Tools <https://aws.amazon.com/cli/>`_. Installation instructions for Windows, macOS and Linux are available on this site.
We also recommend that you install `k9s <https://k9scli.io/>`_, a popular tool for adminstering a Kubernetes cluster.

.. code-block:: shell

  # -------------------------------------
  # to manage an individual resource
  # -------------------------------------
  cd ./terraform/environments/prod/mysql
  terragrunt init
  terragrunt plan
  terragrunt apply
  terragrunt destroy

  # -------------------------------------
  # to build the entire backend
  # -------------------------------------
  cd ./terraform/environments/prod
  terragrunt run-all init
  terragrunt run-all apply


V. Connect To Your new bastion server
-------------------------------------

v1.01 introduced a newly designed bastion server with a complete set of preinstalled and preconfigured software for adminstering your
Open edX platform.

.. image:: ./ec2-bastion.png
  :width: 100%
  :alt: Bastion Welcome Screen


VI. Connect To Your backend Services
------------------------------------

Terraform creates friendly subdomain names for any of the backend services which you are likely to connect: Cloudfront, MySQL, Mongo and Redis.
Passwords for the root/admin accounts are accessible from Kubernetes Secrets. Note that each of MySQL, MongoDB and Redis reside in private subnets. These services can only be accessed on the command line from the Bastion.

.. code-block:: shell

  ssh bastion.service.yourschool.edu -i path/to/yourschool-ohio.pem

  mysql -h mysql.service.yourschool.edu -u root -p

  mongo --port 27017 --host mongo.service.yourschool.edu -u root -p

  redis-cli -h redis.service.yourschool.edu -p 6379

Specifically with regard to MySQL, several 3rd party analytics tools provide out-of-the-box connectivity to MySQL via a bastion server. Following is an example of how to connect to your MySQL environment using MySQL Workbench.

.. image:: ./mysql-workbench.png
  :width: 700
  :alt: Connecting to MySQL Workbench


VII. Manage your new Kubernetes cluster
---------------------------------------

Installs four of the most popular web applications for Kubernetes administration:

- `k9s <https://k9scli.io/>`_, preinstalled in the optional EC2 Bastion server. K9s is an amazing retro styled, ascii-based UI for viewing and monitoring all aspects of your Kubernetes cluster. It looks and runs great from any ssh-connected terminal window.
- `Kubernetes Dashboard <https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/>`_. Written by the same team that maintain Kubernetes, Kubernetes Dashboard provides an elegant web UI for monitoring and administering your kubernetes cluster.
- `Kubeapps <https://kubeapps.dev/>`_. Maintained by VMWare Bitnami, Kubeapps is the easiest way to install popular open source software packages from MySQL and MongoDB to Wordpress and Drupal.
- `Grafana <https://grafana.com/>`_. Provides an elegant web UI to view time series data gathered by prometheus and metrics-server.
  - user: admin
  - pwd: prom-operator


VIII. Add more Kubernetes admins
--------------------------------

By default access to the Kubernetes cluster is limited to the cluster creator (presumably, you) and the IAM user for the bastion server.
Also note that by default, Kubernetes version 1.25 and newer encrypts all secrets data using `AWS Key Management Service (KMS) <https://aws.amazon.com/kms/>`_.
The Cookiecutter automatically adds the IAM user for the bastion server, but you'll need to add other IAM users to this list, or if you prefer, you can disable encrypted Kubernetes secrets by setting Cookiecutter parameter eks_create_kms_key=N.

You can add more IAM users to the cluster admin and AWS KMS key owner lists by modifying terraform/stacks/{{cookiecutter.global_platform_shared_resource_identifier}}/kubernetes/terragrunt.hcl`_, as follows:

.. code-block:: terraform

    kms_key_owners = [
      "${local.bastion_iam_arn}",
      userarn  = "arn:aws:iam::${local.account_id}:user/mcdaniel",
      userarn  = "arn:aws:iam::${local.account_id}:user/bob_marley",
    ]

    map_users = [
      {
        userarn  = local.bastion_iam_arn
        username = local.bastion_iam_username
        groups   = ["system:masters"]
      },
      {
        userarn  = "arn:aws:iam::${local.account_id}:user/mcdaniel"
        username = "mcdaniel"
        groups   = ["system:masters"]
      },
      {
        userarn  = "arn:aws:iam::${local.account_id}:user/bob_marley"
        username = "bob_marley"
        groups   = ["system:masters"]
      },
    ]

If you're new to Kubernetes then you can read more about cluster access in the AWS EKS documentation, `Enabling IAM user and role access to your cluster <https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html>`_.
You'll need kubectl in order to modify the aws-auth configMap in your Kubernets cluster.

.. code-block:: bash

    kubectl edit -n kube-system configmap/aws-auth

Following is an example aws-auth configMap with additional IAM user accounts added to the admin "masters" group.

.. code-block:: yaml

    # Please edit the object below. Lines beginning with a '#' will be ignored,
    # and an empty file will abort the edit. If an error occurs while saving this file will be
    # reopened with the relevant failures.
    #
    apiVersion: v1
    data:
      mapRoles: |
        - groups:
          - system:bootstrappers
          - system:nodes
          rolearn: arn:aws:iam::012345678942:role/service-eks-node-group-20220518182244174100000002
          username: system:node:{% raw %}{{EC2PrivateDNSName}}{% endraw %}
        - groups:
          - system:bootstrappers
          - system:nodes
          rolearn: arn:aws:iam::012345678942:role/hosting-eks-node-group-20220518182244174100000001
          username: system:node:{% raw %}{{EC2PrivateDNSName}}{% endraw %}
      mapUsers: |
        - groups:
          - system:masters
          userarn: arn:aws:iam::012345678942:user/mcdaniel
          username: mcdaniel
        - groups:
          - system:masters
          userarn: arn:aws:iam::012345678942:user/bob_marley
          username: bob_marley
    kind: ConfigMap
    metadata:
      creationTimestamp: "2022-05-18T18:38:29Z"
      name: aws-auth
      namespace: kube-system
      resourceVersion: "499488"
      uid: 52d6e7fd-01b7-4c80-b831-b971507e5228



Continuous Integration (CI)
---------------------------

Both the Build as well as the Deploy workflows will be pre-configured based on your responses to the Cookiecutter questionnaire.


I. Build your Tutor Docker Image(s)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The automated Github Actions workflow "Build openedx Image" in your new repository will build a customized Open edX Docker container based on the latest stable version of Open edX and
your Open edX custom theme repository and Open edX plugin repository. Your new Docker image will be automatically uploaded to AWS Amazon Elastic Container Registry.


II. Deploy your Docker Image to your Kubernetes Cluster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The automated Github Actions workflow "prod Deploy to Kubernetes" in your new repository will deploy your customized Docker container to a Kubernetes Cluster. You can optionall run the Github Actions workflow "prod Deploy optional Open edX modules to Kubernetes" to install all optional modules and plugins as well as the base Open edX platform software.
